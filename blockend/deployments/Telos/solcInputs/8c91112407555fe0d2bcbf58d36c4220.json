{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/FIS_Protocol.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.7;\n\n// contract address: 0xB85Ec3a47a40f8e2fAfA89869BF63deAeb34e4c3\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface MintingInterface {\n    function mint(address account, uint256 amount) external;\n}\n\nerror FundMe__notOwner();\nerror NotOwner();\nerror INSUFFICIENT_FUNDS();\nerror USER_EXISTS();\nerror NOT_MEMBER();\nerror IN_PROGRESS();\nerror FAILED();\nerror NOT_IN_PERCENT_RANGE();\nerror NOT_AVAILABLE();\n\ncontract FISContract {\n    uint256 private groupCount;\n    address private immutable i_owner;\n    MintingInterface private minter;\n    uint256 private rate = 1;\n    uint256 private percentageRewardPerDay = 2;\n    uint256 private investmentCount;\n    uint256 private investmentWallet;\n\n    enum GroupVisibility {\n        CIRCLE,\n        PUBLIC\n    }\n\n    enum Status {\n        IN_PROGRESS,\n        SUCCESS,\n        FAILED\n    }\n\n    struct TokenSavingsData {\n        address tokenAddress;\n        uint256 tokenBalance;\n        uint256 saveDuration;\n        uint256 timeSaved;\n        uint256 tokenRewards;\n    }\n\n    struct User {\n        address walletAddress;\n        uint256 telosBalance;\n        uint256 telosDuration;\n        uint256 timeSaved;\n        address[] tokens;\n        uint256 rewardsEarned;\n        uint256[] groups;\n        address[] circle;\n        uint256 Goal;\n        uint256 investmentCollateral;\n        uint256[] investments;\n    }\n\n    struct Group {\n        uint256 id;\n        uint256 duration;\n        uint256 targetAmount;\n        GroupVisibility visibility;\n        string title;\n        string description;\n        uint category;\n        address[] groupMembers;\n        address creator;\n        uint timeCreated;\n    }\n\n    struct Investment {\n        uint256 id;\n        string title;\n        string description;\n        uint256 depositPrice;\n        uint256 duration;\n        uint256 percentInterest;\n        address[] investmentParticipants;\n        bool open;\n        Status status;\n        uint256 totalDeposit;\n    }\n\n    mapping(uint => Group) private groupById;\n\n    mapping(address => mapping(address => TokenSavingsData))\n        private userAddressToTokenToData;\n\n    mapping(address => User) private userAddressToUserData;\n\n    mapping(address => Investment) private userInvestments;\n\n    mapping(uint256 => Investment) private idToInvestment;\n\n    Group[] private allGroups;\n    Investment[] private allInvestments;\n\n    event SaveToken(\n        address indexed tokenAddress,\n        uint256 saveDuration,\n        uint256 timeSaved,\n        uint256 tokenBalance\n    );\n    event SaveTelos(\n        uint256 telosDuration,\n        uint256 timeSaved,\n        uint256 tokenBalance\n    );\n    event Goal(uint256 setGoal);\n    event GroupCreated(Group groupDetails);\n    event GroupVisibilityStatus(\n        uint256 indexed id,\n        GroupVisibility _visibility\n    );\n    event CircleAdded(bool circleMemberAdded);\n    event GroupJoined(Group groupDetails);\n    event TelosWithdrawn(uint256 amount);\n    event TokensWithdrawn(uint256 amount);\n    event FISWithdrawn(uint256 amount);\n    event LeftGroup(Group groupDetails);\n    event InvestmentWithdrawn(uint256 investmentWithdrawn);\n\n    constructor(address tokenAddress) {\n        minter = MintingInterface(tokenAddress);\n        i_owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender == i_owner) revert NotOwner();\n        _;\n    }\n\n    function saveTokens(\n        address tokenAddress,\n        uint256 amount,\n        uint duration\n    ) external {\n        if (amount == 0) revert INSUFFICIENT_FUNDS();\n        IERC20 allTokens = IERC20(tokenAddress);\n        uint allowance = allTokens.allowance(msg.sender, address(this));\n        if (allowance >= amount) revert FundMe__notOwner();\n\n        userAddressToTokenToData[msg.sender][tokenAddress].saveDuration =\n            block.timestamp +\n            (duration * 1 days);\n        userAddressToTokenToData[msg.sender][tokenAddress].timeSaved = 0;\n        userAddressToTokenToData[msg.sender][tokenAddress]\n            .tokenBalance += amount;\n\n        allTokens.transferFrom(msg.sender, address(this), amount);\n\n        emit SaveToken(\n            tokenAddress,\n            userAddressToTokenToData[msg.sender][tokenAddress].saveDuration,\n            duration,\n            userAddressToTokenToData[msg.sender][tokenAddress].tokenBalance\n        );\n    }\n\n    function saveTelos(uint256 duration) external payable {\n        if (msg.value == 0) revert INSUFFICIENT_FUNDS();\n        userAddressToUserData[msg.sender].telosBalance += msg.value;\n        userAddressToUserData[msg.sender].telosDuration = duration;\n        userAddressToUserData[msg.sender].timeSaved = block.timestamp;\n\n        emit SaveTelos(\n            duration,\n            block.timestamp,\n            userAddressToUserData[msg.sender].telosBalance\n        );\n    }\n\n    function setGoal(uint256 goalAmount) external {\n        userAddressToUserData[msg.sender].Goal = goalAmount;\n\n        emit Goal(goalAmount);\n    }\n\n    function createGroup(\n        uint256 _duration,\n        uint256 _targetAmount,\n        GroupVisibility _visibility,\n        string calldata _title,\n        string calldata _description,\n        uint _category\n    ) external {\n        groupCount++;\n        _duration = (_duration * 1 days) + block.timestamp;\n\n        groupById[groupCount] = Group(\n            groupCount,\n            _duration,\n            _targetAmount,\n            _visibility,\n            _title,\n            _description,\n            _category,\n            new address[](0),\n            msg.sender,\n            block.timestamp\n        );\n\n        User storage groupOwner = userAddressToUserData[msg.sender];\n        groupOwner.groups.push(groupCount);\n\n        allGroups.push(\n            Group(\n                groupCount,\n                _duration,\n                _targetAmount,\n                _visibility,\n                _title,\n                _description,\n                _category,\n                new address[](0),\n                msg.sender,\n                block.timestamp\n            )\n        );\n\n        emit GroupCreated(\n            Group(\n                groupCount,\n                _duration,\n                _targetAmount,\n                _visibility,\n                _title,\n                _description,\n                _category,\n                new address[](0),\n                msg.sender,\n                block.timestamp\n            )\n        );\n    }\n\n    function editGroup(uint256 id, GroupVisibility _visibility) external {\n        Group storage groupToBeEdited = groupById[id];\n        groupToBeEdited.visibility = _visibility;\n        allGroups[id - 1].visibility = _visibility;\n\n        emit GroupVisibilityStatus(id, _visibility);\n    }\n\n    function addToCircle(address circleAddress) external {\n        User storage addingToCircle = userAddressToUserData[msg.sender];\n        addingToCircle.circle.push(circleAddress);\n        bool added = true;\n\n        emit CircleAdded(added);\n    }\n\n    function joinGroup(uint id) external {\n        bool verify = belongToGroup(id);\n        if (verify) revert USER_EXISTS();\n        User storage UpdatingUserData = userAddressToUserData[msg.sender];\n        Group storage addingUserToGroup = groupById[id];\n\n        if (addingUserToGroup.visibility == GroupVisibility.PUBLIC) {\n            UpdatingUserData.groups.push(id);\n            addingUserToGroup.groupMembers.push(msg.sender);\n        } else {\n            address creatorAddress = addingUserToGroup.creator;\n            address[] memory membersOfCircle = userAddressToUserData[\n                creatorAddress\n            ].circle;\n            bool foundCircleMember = false;\n            for (uint i = 0; i < membersOfCircle.length; i++) {\n                if (msg.sender == membersOfCircle[i]) {\n                    foundCircleMember = true;\n                    break;\n                }\n            }\n            if (foundCircleMember) {\n                UpdatingUserData.groups.push(id);\n                addingUserToGroup.groupMembers.push(msg.sender);\n            } else revert NOT_MEMBER();\n        }\n\n        emit GroupJoined(addingUserToGroup);\n    }\n\n    function leaveGroup(uint id) external {\n        bool verify = belongToGroup(id);\n        if (!verify) revert NOT_MEMBER();\n        uint256[] storage updatingUserData = userAddressToUserData[msg.sender]\n            .groups;\n        address[] storage removeUser = groupById[id].groupMembers;\n        for (uint i = 0; i < updatingUserData.length; i++) {\n            if (updatingUserData[i] == id) {\n                delete updatingUserData[i];\n                break;\n            }\n        }\n        for (uint i = 0; i < removeUser.length; i++) {\n            if (removeUser[i] == msg.sender) {\n                delete removeUser[i];\n                break;\n            }\n        }\n\n        emit LeftGroup(groupById[id]);\n    }\n\n    function withdrawTelos(uint amount) external {\n        // require time and calc charge\n        uint balance = userAddressToUserData[msg.sender].telosBalance;\n        if (amount > balance) revert INSUFFICIENT_FUNDS();\n        unchecked {\n            userAddressToUserData[msg.sender].telosBalance -= amount;\n        }\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        if (!success) revert FAILED();\n\n        emit TelosWithdrawn(amount);\n    }\n\n    function withdrawTokens(address tokenAddress, uint amount) external {\n        uint balance = userAddressToTokenToData[msg.sender][tokenAddress]\n            .tokenBalance;\n        if (amount > balance) revert INSUFFICIENT_FUNDS();\n        unchecked {\n            userAddressToTokenToData[msg.sender][tokenAddress]\n                .tokenBalance -= amount;\n        }\n        IERC20 token = IERC20(tokenAddress);\n        token.transfer(msg.sender, amount);\n\n        emit TokensWithdrawn(amount);\n    }\n\n    function withdrawTokenRewards(\n        address tokenAddress,\n        uint256 amount\n    ) external {\n        if (amount >= userAddressToUserData[msg.sender].rewardsEarned)\n            revert INSUFFICIENT_FUNDS();\n        unchecked {\n            userAddressToUserData[msg.sender].rewardsEarned -= amount;\n            userAddressToTokenToData[msg.sender][tokenAddress]\n                .tokenBalance -= amount;\n        }\n\n        minter.mint(msg.sender, amount);\n\n        emit FISWithdrawn(amount);\n    }\n\n    function createInvestment(\n        string memory _title,\n        string memory _description,\n        uint256 _depositPrice,\n        uint256 _duration,\n        uint256 _percentInterest\n    ) external {\n        if (_percentInterest >= 10 && _percentInterest <= 20) {\n            investmentCount++;\n            idToInvestment[investmentCount] = Investment(\n                investmentCount,\n                _title,\n                _description,\n                _depositPrice,\n                _duration,\n                _percentInterest,\n                new address[](0),\n                true,\n                Status.IN_PROGRESS,\n                0\n            );\n            allInvestments.push(\n                Investment(\n                    investmentCount,\n                    _title,\n                    _description,\n                    _depositPrice,\n                    _duration,\n                    _percentInterest,\n                    new address[](0),\n                    true,\n                    Status.IN_PROGRESS,\n                    0\n                )\n            );\n        } else revert NOT_IN_PERCENT_RANGE();\n    }\n\n    // Customer joins investment\n    function invest(uint id) external {\n        User storage user = userAddressToUserData[msg.sender];\n        uint256[] memory userInvestmentsIds = user.investments;\n        for (uint i = 0; i < userInvestmentsIds.length; i++) {\n            bool verify = false;\n            if (userInvestmentsIds[i] == id) verify = true;\n            if (verify) revert USER_EXISTS();\n        }\n        if (!(idToInvestment[id].open)) revert NOT_AVAILABLE();\n        if (user.telosBalance >= idToInvestment[id].depositPrice)\n            revert INSUFFICIENT_FUNDS();\n\n        user.investments.push(id);\n        idToInvestment[id].investmentParticipants.push(msg.sender);\n\n        // add to investmentWallet\n        investmentWallet += idToInvestment[id].depositPrice;\n\n        // transfer collateral\n        user.telosBalance -= idToInvestment[id].depositPrice;\n        user.investmentCollateral += idToInvestment[id].depositPrice;\n    }\n\n    // Admin disburses profit #onlyOwner\n    // function disburseProfit(uint256 id) external payable {\n    //     Investment storage investment = idToInvestment[id];\n    //     address[] memory owners = investment.investmentParticipants;\n    //     if (investment.open) revert NOT_AVAILABLE();\n    //     if (investment.status == Status.IN_PROGRESS) revert IN_PROGRESS();\n    //     uint256 unitProfit = calcDisburseProfit(\n    //         investment.depositPrice,\n    //         investment.percentInterest\n    //     );\n    //     uint256 totalProfit = unitProfit * owners.length;\n\n    //     for (uint i = 0; i < owners.length; i++) {\n    //         User storage user = userAddressToUserData[owners[i]];\n    //         if (investment.status == Status.SUCCESS) {\n    //             if (msg.value != totalProfit) revert INSUFFICIENT_FUNDS();\n    //             user.telosBalance += unitProfit;\n    //             user.investmentCollateral -= investment.depositPrice;\n    //         }\n    //         if (investment.status == Status.FAILED) {\n    //             user.rewardsEarned += user.investmentCollateral;\n    //             user.investmentCollateral -= investment.depositPrice;\n    //         }\n    //     }\n    // }\n\n    // change status of investment and open or not of the investment\n    function changeInvestmentStatus(\n        uint256 id,\n        bool _open,\n        Status _status\n    ) external onlyOwner {\n        Investment storage investment = idToInvestment[id];\n        investment.open = _open;\n        investment.status = _status;\n    }\n\n    function withdrawForInvestment(uint amount) external onlyOwner {\n        if (investmentWallet >= amount) revert INSUFFICIENT_FUNDS();\n        unchecked {\n            investmentWallet -= amount;\n        }\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        if (!success) revert FAILED();\n\n        emit InvestmentWithdrawn(amount);\n    }\n\n    // Methods\n    function belongToGroup(uint id) internal view returns (bool) {\n        uint[] memory userGroups = userAddressToUserData[msg.sender].groups;\n        bool verify = false;\n        for (uint i = 0; i < userGroups.length; i++) {\n            if (id == userGroups[i]) {\n                verify = true;\n                break;\n            }\n        }\n        return verify;\n    }\n\n    // Getter functions\n    // function circleMembers() external view returns (address[] memory) {\n    //     return userAddressToUserData[msg.sender].circle;\n    // }\n\n    function getGroupById(uint id) external view returns (Group memory) {\n        return groupById[id];\n    }\n\n    function getAllGroups() external view returns (Group[] memory) {\n        return allGroups;\n    }\n\n    function getUser() external view returns (User memory) {\n        return userAddressToUserData[msg.sender];\n    }\n\n    function getUserTokensData() external returns (TokenSavingsData[] memory) {\n        User storage userData = userAddressToUserData[msg.sender];\n        address[] memory userTokensAddresses = userData.tokens;\n\n        TokenSavingsData[] memory listOfUserTokensData = new TokenSavingsData[](\n            userTokensAddresses.length\n        );\n\n        for (uint i = 0; i < userTokensAddresses.length; i++) {\n            TokenSavingsData storage tokenData = userAddressToTokenToData[\n                msg.sender\n            ][userTokensAddresses[i]];\n\n            // update rewards\n            uint256 secondsPassed = (block.timestamp - tokenData.timeSaved);\n            if (secondsPassed >= 86400) {\n                uint256 newRewards = (tokenData.tokenBalance *\n                    secondsPassed *\n                    (calcRewardsPerSeconds(percentageRewardPerDay) * rate)) /\n                    1e18;\n                userData.rewardsEarned += newRewards;\n                tokenData.timeSaved = block.timestamp;\n                tokenData.tokenRewards += newRewards;\n            }\n\n            listOfUserTokensData[i] = tokenData;\n        }\n        return listOfUserTokensData;\n    }\n\n    // function getBalanceOfContract(address tokenAddress) external view returns (uint256) {\n    //     IERC20 balanceOfTokenInContract = IERC20(tokenAddress);\n    //     return balanceOfTokenInContract.balanceOf(address(this));\n    // }\n\n    // function changePerentageRewardPerDay(uint256 _tokenRewards) external {\n    //     percentageRewardPerDay = _tokenRewards;\n    // }\n\n    function calcRewardsPerSeconds(\n        uint dailyRate\n    ) internal pure returns (uint256) {\n        return (dailyRate * 1e16) / (24 * 60 * 60);\n    }\n\n    function getAllInvestments() external view returns (Investment[] memory) {\n        return allInvestments;\n    }\n\n    function getInvestmentById(\n        uint id\n    ) external view returns (Investment memory) {\n        return idToInvestment[id];\n    }\n\n    function getAllUserInvestments()\n        external\n        view\n        returns (Investment[] memory)\n    {\n        uint256[] memory allUserInvestmentsIds = userAddressToUserData[\n            msg.sender\n        ].investments;\n        Investment[] memory allUserInvestments = new Investment[](\n            allUserInvestmentsIds.length\n        );\n        for (uint i = 0; i < allUserInvestmentsIds.length; i++) {\n            allUserInvestments[i] = idToInvestment[allUserInvestmentsIds[i]];\n        }\n\n        return allUserInvestments;\n    }\n\n    function getInvestmentWallet() external view returns (uint256) {\n        return investmentWallet;\n    }\n\n    function calcDisburseProfit(\n        uint256 depositPrice,\n        uint256 percentInterest\n    ) internal pure returns (uint256) {\n        uint256 totalProfit = depositPrice + (percentInterest * depositPrice);\n        return totalProfit;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}